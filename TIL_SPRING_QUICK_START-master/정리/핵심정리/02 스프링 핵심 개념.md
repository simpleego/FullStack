스프링 핵심 개념
=======================
프레임워크 용어
스프링의 핵심 개념
 * DI
 * IoC
 * AOP & AOP Proxy
 * AOP in Spring
 
# 1. POJO
```
Plain Old Java Object  -> 오래된 방식의 간단한 자바 오브젝트
어떠한 제한에도 묶이지 않은 자바 오브젝트라고 할 수 있다.
   
1.클래스 상속을 강제하지 않는다.  
2.인터페이스 구현을 강제하지 않는다.
3.애노테이션 사용을 강제하지 않는다.
   
즉 우리가 자유롭게 구성하여 사용할 수 있는 클래스를 의미 
이런 이유를 사용하는 이유는 java-Beans와 EJB-Beans와 구분이 모호하고 다른 용어와 확실한 분리를 위해 POJO라 사용 

예를 들면 서블릿은 HttpServlet을 필수적으로 상속받아야 하니 POJO 클래스가 아니다.
반대로 우리가 자유롭게 정의하고 만들 수 있는 클래스들은 POJO 클래스이다.
참고로 POJO는 자바 표준 스펙이 아니다. 
```
   
# 2. DI 의존성 주입
**일체형**   
![일체형](https://user-images.githubusercontent.com/50267433/71542583-8bcf8180-29ab-11ea-8f9a-e1a84eb82f75.png)   
**분리/도킹형**   
![분리도킹형](https://user-images.githubusercontent.com/50267433/71542584-8ffb9f00-29ab-11ea-990a-e7793f67f3ae.png)  
```
일체형은 A 객체의 내부 프로세스에 대해 신경 쓸 필요가 없다. 
분리형은 A와 B를 개별적으로 세팅해 주어야 한다. 
단, 분리형은 내가 원하는 것으로 바꾸어 부착할 수 있다. 

이는 유지보수 관리 차원에서 
일체형 형식의 파일에서 공통 코드를 바꾼다 가정할 시에 파일의 갯수만큼 고쳐야한다.

반대로 분리형은 
객체를 생성하는 하나의 클래스가 있고 그 클래스에서 100개의 파일에 객체를 제공해준다면 
우리는 객체를 생성한 하나의 클래스만 수정해주면 100개가 수정될 수 있다.  

그렇기에 분리/도킹(부착) 형으로 개발을 하게 되면 각 객체간의 결합도를 낮출 수 있으며, 
DI를 사용하는 목적이 이러한 결합도를 낮추기 위한것이라 할 수 있다.
```
## 2.1. DI의 종류
* Setter Injection : 세터 주입
* Construction Injection : 생성자 주입

```
Setter Injection
 B b = new B();
 A a = new A();
 a.setB(b);

Construction Injection
 B b = new B();
 A a = new A(b);
```
## 2.2. 스프링에서의 DI
기존 프로세스 : 일체형으로 메인 클래스에서 서브 클래스들을 생성하여 이를 부품과 도구 처럼 활용하여 사용 (직접 생성)    
스프링 프로세스 : 분리/도킹형으로 컨테이너에서 서브 클래스들을 생성하여 메인 클레스에서 DI로 받는 방식  
```
이처럼 내가 필요한 객체들을 하나 하나 생성해서 사용하는 방식이 아닌 
기존에 생성된 객체들을 가져와서 사용하는 방식이 바로 스프링 프로세스이다.   

이렇듯 기본적인 프로세스 순서와는 다르게 작은 모듈부터 큰 모듈로, 제품을 만드는 순서가 역순이라 하여
IoC 라는 용어가 탄생하게 되었다.(Inversion of Control)
```

***
# 3. IOC 제어의 역행
DI를 이용하여 객체를 직접 생성하는 것이 아닌 받는 것으로        
기존 프로세스와 달리 객체의 생성 흐름이 반대로 동작하는 것을 의미 (서브 먼저 생성 후 사용)        
## 3.1. IoC 컨테이너 (스프링 컨테이너)
**빈(bean)**
```
스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트(getter/setter 및 생성자를 가진 클래스)
```
**빈 팩토리(Bean Factory)**
```
빈(오브젝트)의 생성과 관계 설정 제어를 담당하는 IoC오브젝트. 
즉 단순히 객체 생성과 주입을 담당하는 오브젝트를 의미 

실제로는 팩토리를 좀 더 확장한 애플리케이션 컨텍스트(application context)를 주로 사용한다.
```
**애플리케이션 컨텍스트(IoC 컨테이너 or 스프링 컨테이너)**
```
DI를 위한 빈 팩토리에 엔터프라이즈 어플레이케이션을 개발하는데 필요한 여러가지 기능을 추가한 것 
```
**설정정보/설정 메타정보**
```
구성정보 or 형상정보 (XML)
```
**스프링 컨테이너(IoC 컨테이너)**
```
IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 의미.
즉 팩토리나 컨텍스트를 아우르는 넓은 의미
```
![SPringDI](https://user-images.githubusercontent.com/50267433/71543013-401fd680-29b1-11ea-935d-e35a16b8e43a.png)

* EJB(Enterprise Java Bean) : 효율적으로 서버 관리를 해주고, 또 프로그램 관련 문제들을 알아서 처리해준다는 개념.   
  (연결 관계가 복잡하고, 무겁고, 독립적이지 못하다)  
* DL(Dependency Lookup)  
* DI(Dependency Injection)

 

**DL(Dependecy Lookup)**
```
JNDI 같은 저장소에서 관리되고 있는 bean을 개발자들이 직접 컨테이너에서 제공하는 API를 이용하여 lookup하는 것을 말함.
따라서 container와의 종속성이 생김. (JNDI 컨테이너에 의존성이 강하다. )
```
오브젝트간에 디커플링(decoupling)을 해주는 면에서 장점이 있지만 (의존 결합을 방지)       
이렇게 만들어진 오브젝트는 컨테이너 밖에서 실행 할 수 없고        
JNDI외의 방법을 사용할 경우 JNDI관련 코드를 오브젝트내에 일일히 변경해 줘야 하며        
테스트하기 매우 어렵고 코드 양이 매우 증가하고 매번 Casting해야 하고            
NamingException같은 checked exception을 처리하기 위해서 exception처리구조가 매우 복잡해지는 단점이 있다.   
(EJB container, Spring container 에서 지원한다.)  

**DI (Dependecy Injection)**
```
각 class 사이의 의존관계를 빈 설정 정보를 바탕으로 container가 자동적으로 연결해 주는 것을 말함. 
따라서 lookup과 관련된 코드들이 오브젝트 내에서 완전히 사라지고 컨테이너에 의존적이지 않은 코드를 작성할 수 있음.
```
  
단지 빈 설정 파일에서 의존관계가 필요하다는 정보를 추가하면 됨.    
* Setter Injection : 클래스 사이의 의존관계를 연결을 위해 setter 메소드를 이용 (property tag 사용)
* Constructor Injection : 클래스 사이의 의존관계를 연결을 위해 constructor를 이용하는 방법. (constructor-arg tag 사용)
* Method Injection : 싱글톤(Singleton) 인스턴스와 non singleton 인스턴스의 의존관계를 연결시킬 필요가 있을 때 사용

출처: https://ooz.co.kr/178?category=818548 [이러쿵저러쿵]

# 3. AOP 관점 지향 프로그래밍
**Aspect Oriented Programming** : 횡단 관심사와 이에 영향 받는 객체 간의 결합도를 낮추는 것 
![aop](https://user-images.githubusercontent.com/50267433/71543123-ee784b80-29b2-11ea-8f2a-da8650b86c05.jpg)
  
**핵심 관심** : 해당 시스템의 핵심 가치와 목적이 그대로 드러나는 핵심 비즈니스 로직 (고유한 기능)   
**횡단 관심** : 로깅이나 예외, 트랜잭션 처리 같은 AOP에서 메소드마다 공통으로 등장하는 로직 (공통된 기능)     

## 3.1. AOP의 장점
```
여타 서비스 모듈이 자신의 주요 관심 사항(또는 핵심 기능)에 대한 코드만 포함하고 
그 외의 관심 사항은 모두 Aspect로 옮겨지므로 코드가 깔끔해지고, 가독성이 높아짐.
```
## 3.2. AOP 프로세스
기존의 개발 방식 : 주 업무 코드 사이사이에 보조 업무를 담당하는 코드가 포함되어 있고 파일마다 반복적으로 기술   
보조 업무가 주 업무 코드에 포함될 때에는 다음과 같은 일이 발생.   
  * 동일한 작업 반복.  
  * 보조 업무의 작업 코드가 변경될 시, 해당 보조 업무를 사용하는 모든 주 업무 코드의 소스 수정 필요.   
  * 주 업무 코드보다 더 많은 양의 보조 업무 코드 – 특히 DB 객체 생성 및 접속, 예외 처리, DB 닫기 등.   
```
AOP는 이러한 보조 업무 코드를 주 업무 코드에서 별도로 분리하여 작성하고, 
필요할 때에만 도킹(Docking)하여 사용하는 것은 어떨까? 하는 발상에서 나온 개념.
```
주 업무에서 보조 업무를 잘라내었다(횡단으로)는 의미로 Cross-Cutting 이라 부른다.   
